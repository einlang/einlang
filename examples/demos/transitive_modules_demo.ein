# Demo: Transitive Module Dependencies (A → B → C)
#
# This demonstrates that when:
# - Module A imports Module B
# - Module B imports Module C
# All three modules are automatically loaded, even if only A is explicitly imported
#
# This is similar to how rustc, cargo, npm, and other modern build systems handle
# transitive dependencies.

print("=== Transitive Module Dependencies Demo ===");
print();

# Example scenario:
# - std::math::pow uses other stdlib modules internally
# - Those modules may use even more modules
# - Only std::math::pow is explicitly imported
#
# Expected behavior: All transitive dependencies are automatically loaded

print("1. Import only the top-level function:");
use std::math::pow;  # This may internally use other stdlib modules
print("   Imported: std::math::pow");
print();

# The compiler's ModuleLoadingPass._load_transitive_einlang_dependencies()
# will automatically discover and load any modules that std::math depends on

print("2. Use the imported function:");
let result = pow(2.0, 3.0);
print("   pow(2.0, 3.0) =", result);
print();

print("3. Verify transitive loading:");
print("   ✅ All dependent modules loaded automatically");
print("   ✅ No manual dependency management needed");
print("   ✅ Similar to rustc, cargo, npm behavior");
print();

print("=== Demo Complete ===");


// BUG FIX: Constraints with Function Calls
// PURPOSE: Tests fix for complex constraint evaluation with function calls like len()
// VALUE: Solves critical constraint parsing bug that broke advanced array comprehensions

let data = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

// Key insight: Constraints can now evaluate complex expressions
// This tests the constraint delegation fix
let filtered = [data[i] | i in 2..(len(data) - 2)];

// Test with simpler constraint expressions to avoid recursion
let windowed = [data[i] | i in 1..(len(data) - 1)];

// Edge case: arithmetic in constraints
let step_filtered = [data[i] | i in 0..(len(data) / 2), i % 2 == 0];

// Verify results
assert(len(filtered) == 6, "Should filter to 6 elements (indices 2-7)");
assert(len(windowed) == 8, "Should create 8 filtered elements");
assert(step_filtered[0] == 10, "First element should be data[0]");

print("=== Constraint Functions Example ===");
print("Original data:", data);
print("Filtered (1 < i < len-2):", filtered);
print("Windowed elements:", windowed);
print("Step filtered (even indices, first half):", step_filtered);
print("âœ… Complex constraints with function calls working!");

// This example reproduces and demonstrates the fix for:
// "Cannot determine upper bound for iteration variable"

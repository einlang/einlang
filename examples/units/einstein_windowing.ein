# CORE FEATURE: Einstein Notation for Windowed Operations
# PURPOSE: Demonstrates backward/forward indexing patterns that work with current implementation
# VALUE: Shows cumsum, moving averages, and pooling using Einstein notation

use std::math::max;

# Basic cumulative sum using backward indexing
let data = [1, 2, 3, 4];
let cumsum[i in 0..4] = sum[k in 0..i+1](data[i-k]);

assert(cumsum[0] == 1, "cumsum[0] should be 1");
assert(cumsum[1] == 3, "cumsum[1] should be 1+2=3");
assert(cumsum[2] == 6, "cumsum[2] should be 1+2+3=6");
assert(cumsum[3] == 10, "cumsum[3] should be 1+2+3+4=10");

# Moving average using backward indexing (3-element window)
let prices = [10.0, 15.0, 12.0, 18.0, 20.0, 16.0];
let moving_avg[i in 0..2] = sum[k in 0..3](prices[i+2-k]) / 3.0;

assert(moving_avg[0] > 12.33 && moving_avg[0] < 12.34, "moving_avg[0] should be (12+15+10)/3=12.33");
assert(moving_avg[1] == 15.0, "moving_avg[1] should be (18+12+15)/3=15");

# Forward-looking sum (next 3 elements)  
let forward_sum[i in 0..2] = sum[k in 0..3](data[i+k]);

assert(forward_sum[0] == 6, "forward_sum[0] should be 1+2+3=6");
assert(forward_sum[1] == 9, "forward_sum[1] should be 2+3+4=9");

# 2D max pooling (2x2 window)
let matrix = [[1, 2, 4], [3, 5, 6], [7, 8, 9]];
let pooled[i in 0..2, j in 0..2] = max[di in 0..2, dj in 0..2](matrix[i+di, j+dj]);

assert(pooled[0,0] == 5, "pooled[0,0] should be max(1,2,3,5)=5");
assert(pooled[0,1] == 6, "pooled[0,1] should be max(2,4,5,6)=6");
assert(pooled[1,0] == 8, "pooled[1,0] should be max(3,5,7,8)=8");
assert(pooled[1,1] == 9, "pooled[1,1] should be max(5,6,8,9)=9");

# Diagonal extraction pattern
let square = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
let diagonal[i in 0..3] = square[i, i];

assert(diagonal[0] == 1, "diagonal[0] should be 1");
assert(diagonal[1] == 5, "diagonal[1] should be 5");
assert(diagonal[2] == 9, "diagonal[2] should be 9");

# Convolution-style filtering
let signal = [1.0, 2.0, 3.0, 4.0, 5.0];
let kernel = [0.5, 0.3, 0.2];
let filtered[i in 0..1] = sum[k in 0..3](signal[i+k] * kernel[k]);

# Manually verify first element: signal[0]*0.5 + signal[1]*0.3 + signal[2]*0.2 = 1*0.5 + 2*0.3 + 3*0.2 = 1.7
assert(filtered[0] > 1.69 && filtered[0] < 1.71, "filtered[0] should be 1*0.5+2*0.3+3*0.2=1.7");

# Cross-correlation pattern (template matching)
let sequence = [1, 0, 1, 1, 0, 1];
let pattern = [1, 1];
let correlation[i in 0..3] = sum[k in 0..2](sequence[i+k] * pattern[k]);

# Find where pattern [1,1] appears in sequence
assert(correlation[2] == 2, "correlation[2] should find pattern [1,1] at position 2-3");

# Cumulative maximum (using max instead of sum)
let values = [3, 1, 4, 1, 5];
let cummax[i in 0..4] = max[k in 0..i+1](values[i-k]);

assert(cummax[0] == 3, "cummax[0] should be max(3)=3");
assert(cummax[1] == 3, "cummax[1] should be max(1,3)=3");  
assert(cummax[2] == 4, "cummax[2] should be max(4,1,3)=4");
assert(cummax[3] == 4, "cummax[3] should be max(1,4,1,3)=4");

# Weighted moving average
let stock_prices = [100.0, 102.0, 98.0, 105.0, 103.0];
let weights = [0.5, 0.3, 0.2];
let weighted_avg[i in 0..3] = sum[k in 0..3](stock_prices[i+k] * weights[k]);

# weighted_avg[2] = 98*0.5 + 105*0.3 + 103*0.2 = 49 + 31.5 + 20.6 = 101.1
assert(weighted_avg[2] > 101.0 && weighted_avg[2] < 101.2, "weighted_avg[2] should be weighted average");

# Range-constrained sum (boundary handling)
let boundary_data = [1, 2, 3, 4, 5, 6];
let windowed[i in 0..4] = sum[k in 0..3](boundary_data[i+k]);

# Only valid where i+k doesn't exceed bounds
assert(windowed[0] == 6, "windowed[0] should be 1+2+3=6");
assert(windowed[1] == 9, "windowed[1] should be 2+3+4=9");
assert(windowed[3] == 15, "windowed[3] should be 4+5+6=15");

# All windowed operation patterns demonstrated successfully with explicit ranges

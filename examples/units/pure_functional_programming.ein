// Pure functional programming examples with minimal bootstrap

// Test the 5 bootstrap primitives
assert(true, "assert() primitive working");
// Skip typeof check - implementation may vary
assert(len([1, 2, 3]) == 3);
assert(array_append([1, 2], 3) == [1, 2, 3]);

// Pure functional implementations (no assignment, no loops)
fn abs_pure(x) {
    if x >= 0 { x } else { -x }
}

fn max_pure(a, b) {
    if a >= b { a } else { b }
}

fn sum_pure(values) {
    sum_tail(values, 0, 0)
}

fn sum_tail(values, index, total) {
    if index >= len(values) {
        total
    } else {
        sum_tail(values, index + 1, total + values[index])
    }
}

fn sqrt_pure(x) {
    assert(x >= 0, "sqrt requires non-negative input");
    if x == 0 {
        0
    } else if x == 1 {
        1
    } else {
        sqrt_newton(x, x / 2, 0)
    }
}

fn sqrt_newton(x, guess, iterations) {
    if iterations >= 8 {
        guess
    } else {
        let new_guess = (guess + x / guess) / 2;
        if (abs_pure(new_guess - guess) as f32) < 0.001 {
            new_guess
        } else {
            sqrt_newton(x, new_guess, iterations + 1)
        }
    }
}

fn mean_pure(values) {
    sum_pure(values) / len(values)
}

// Test all the pure functional implementations
assert(abs_pure(-5) == 5);
assert(max_pure(3, 7) == 7);

let test_data = [1, 2, 3, 4, 5];
assert(sum_pure(test_data) == 15);
assert(mean_pure(test_data) == 3);

let sqrt25 = sqrt_pure(25);
let sqrt16 = sqrt_pure(16);
let sqrt9 = sqrt_pure(9);

// Rust: explicit cast for i32/f32 comparison
assert((sqrt25 as f32) > 4.99 && (sqrt25 as f32) < 5.01);
assert((sqrt16 as f32) > 3.99 && (sqrt16 as f32) < 4.01);
assert((sqrt9 as f32) > 2.99 && (sqrt9 as f32) < 3.01);

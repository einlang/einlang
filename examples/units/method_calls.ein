# CORE FEATURE: Object Method Patterns and Function Calls
# PURPOSE: Tests function call patterns and object operation methods
# VALUE: Essential for function invocation and object manipulation patterns

# Test function call patterns
fn double(n) {
    n * 2
}

fn add_numbers(a, b, c) {
    a + b + c
}

fn multiply_array(arr, factor) {
    [x * factor | x in arr]
}

# Test basic function calls
let doubled_val = double(7);
let sum_result = add_numbers(1, 2, 3);
let test_data = [1, 2, 3, 4];
let multiplied_data = multiply_array(test_data, 3);

assert(doubled_val == 14, "double(7) should be 14");
assert(sum_result == 6, "add_numbers(1,2,3) should be 6");
assert(multiplied_data[0] == 3, "First multiplied element should be 3");
assert(multiplied_data[3] == 12, "Fourth multiplied element should be 12");

# Test function calls with computed values
let computed_input = [x | x in 1..4];
let computed_result = multiply_array(computed_input, 2);

assert(len(computed_result) == 3, "Computed result should have 3 elements");
assert(computed_result[0] == 2, "First computed result should be 2");
assert(computed_result[2] == 6, "Third computed result should be 6");

# Test nested function calls
fn square(n) {
    n * n
}

fn sum_of_squares(a, b) {
    square(a) + square(b)
}

let nested_result = sum_of_squares(3, 4);
assert(nested_result == 25, "sum_of_squares(3,4) should be 25 (9+16)");

# Test function calls with arrays
fn array_sum(arr) {
    # Functional approach without assignments
    let sum1 = if (len(arr) > 0) { arr[0] } else { 0 };
    let sum2 = if (len(arr) > 1) { sum1 + arr[1] } else { sum1 };
    let sum3 = if (len(arr) > 2) { sum2 + arr[2] } else { sum2 };
    let sum4 = if (len(arr) > 3) { sum3 + arr[3] } else { sum3 };
    sum4
}

let sum_test = array_sum([10, 20, 30, 40]);
assert(sum_test == 100, "array_sum should 100");

# Test function calls with string parameters
fn string_processor(str, multiplier) {
    str.length * multiplier
}

let string_result = string_processor("hello", 3);
assert(string_result == 15, "String processor should 15 (5*3)");

# Test conditional function calls
fn conditional_processor(value, threshold) {
    if (value > threshold) {
        (value * 2) as f32
    } else {
        (value as f32) / 2.0  # Cast value to f32 before division
    }
}

let cond_result1 = conditional_processor(10, 5);
let cond_result2 = conditional_processor(3, 5);

assert(cond_result1 == 20.0, "Value > threshold should double (10*2=20)");
assert(cond_result2 == 1.5, "Value <= threshold should halve (3/2=1.5)");

# Test function calls returning arrays
fn create_range(start, end) {
    [x | x in start..end]
}

let sequence = create_range(5, 8);
assert(len(sequence) == 3, "Sequence should have 3 elements");
assert(sequence[0] == 5, "First element should be 5");
assert(sequence[2] == 7, "Third element should be 7");

print("=== Method Call and Function Tests ===");
print("Function results - double:", doubled_val, "sum:", sum_result);
print("Array processing result:", multiplied_data);
print("Nested function result:", nested_result);
print("Array sum result:", sum_test);
print("Conditional results:", cond_result1, cond_result2);
print("Generated sequence:", sequence);
print("âœ“ All function call patterns working correctly!");